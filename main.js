/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PouchPublisherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // New: Multiple destinations (empty by default)
  destinations: [],
  selectedDestinationIndex: 0,
  // Default publishing preferences
  publishInternal: true,
  publishPublic: false,
  publishExcerpt: false,
  publishHidden: false,
  defaultTags: "",
  defaultTemplate: "",
  rememberSettings: true,
  // Default ribbon icon visibility
  showOneClickIcon: true,
  showOptionsIcon: true,
  // Empty log by default
  publishLog: [],
  // Empty published posts mapping by default
  publishedPosts: {},
  // Debug logging disabled by default
  enableDebugLogging: false,
  debugLog: [],
  // Audio settings
  includeInPodcast: false,
  publishImmediately: false,
  enableTranscription: true
};
var PouchPublisherPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.oneClickRibbonIcon = null;
    this.optionsRibbonIcon = null;
    this.statusBarItem = null;
    // Audio file validation constants (matching audio_recorder.js)
    this.AUDIO_EXTENSIONS = ["wav", "mp3", "m4a", "caf", "aac", "ogg", "oga", "flac", "webm", "opus", "aif", "aiff", "amr"];
    this.VIDEO_EXTENSIONS = ["m4v", "mp4", "mov", "avi", "mkv", "3gp", "3g2"];
    // Cached regex pattern for audio embed removal (performance optimization)
    this.audioEmbedPattern = null;
    // MIME type mapping for audio files
    this.MIME_TYPES = {
      "wav": "audio/wav",
      "mp3": "audio/mpeg",
      "m4a": "audio/mp4",
      "caf": "audio/x-caf",
      "aac": "audio/aac",
      "ogg": "audio/ogg",
      "oga": "audio/ogg",
      "flac": "audio/flac",
      "webm": "audio/webm",
      "opus": "audio/opus",
      "aif": "audio/aiff",
      "aiff": "audio/aiff",
      "amr": "audio/amr"
    };
  }
  async onload() {
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("pouch-status-bar");
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        this.updateStatusBar(file);
        this.updateFileTitle(file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const file = this.app.workspace.getActiveFile();
        this.updateFileTitle(file);
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && file.path === activeFile.path) {
          this.updateStatusBar(file);
          this.updateFileTitle(file);
        }
      })
    );
    this.updateStatusBar(this.app.workspace.getActiveFile());
    this.updateFileTitle(this.app.workspace.getActiveFile());
    this.updateRibbonIcons();
    this.addCommand({
      id: "publish-to-pouch",
      name: "Publish current note to Pouch (One-Click)",
      callback: async () => {
        await this.publishCurrentNote();
      }
    });
    this.addCommand({
      id: "publish-to-pouch-with-options",
      name: "Publish to Pouch with Options",
      callback: async () => {
        await this.publishWithOptions();
      }
    });
    this.addSettingTab(new PouchPublisherSettingTab(this.app, this));
  }
  updateRibbonIcons() {
    if (this.oneClickRibbonIcon) {
      this.oneClickRibbonIcon.remove();
      this.oneClickRibbonIcon = null;
    }
    if (this.optionsRibbonIcon) {
      this.optionsRibbonIcon.remove();
      this.optionsRibbonIcon = null;
    }
    if (this.settings.showOneClickIcon) {
      this.oneClickRibbonIcon = this.addRibbonIcon("upload-cloud", "Publish to Pouch (One-Click)", async (evt) => {
        await this.publishCurrentNote();
      });
      this.oneClickRibbonIcon.addClass("pouch-publisher-ribbon-class");
    }
    if (this.settings.showOptionsIcon) {
      this.optionsRibbonIcon = this.addRibbonIcon("cloud-cog", "Publish to Pouch with Options", async (evt) => {
        await this.publishWithOptions();
      });
      this.optionsRibbonIcon.addClass("pouch-publisher-options-ribbon-class");
    }
  }
  updateStatusBar(file) {
    if (!this.statusBarItem) return;
    if (!file) {
      this.statusBarItem.setText("");
      this.statusBarItem.style.display = "none";
      return;
    }
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (frontmatter && frontmatter.pouch_destination) {
      const destination = frontmatter.pouch_destination;
      const url = frontmatter.pouch_url || "";
      this.statusBarItem.setText(`\u{1F4E4} ${destination}`);
      this.statusBarItem.style.display = "inline-block";
      this.statusBarItem.style.cursor = "pointer";
      this.statusBarItem.onclick = null;
      this.statusBarItem.onclick = async () => {
        await this.publishWithOptions();
      };
      this.statusBarItem.setAttribute("aria-label", `Published to ${destination}${url ? ": " + url : ""}`);
    } else {
      this.statusBarItem.setText("");
      this.statusBarItem.style.display = "none";
    }
  }
  updateFileTitle(file) {
    const existingIcons = document.querySelectorAll(".pouch-publish-status-icon");
    existingIcons.forEach((icon) => icon.remove());
    if (!file) return;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (frontmatter && frontmatter.pouch_destination) {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (!activeLeaf) return;
      const viewHeaderTitle = activeLeaf.view.containerEl.querySelector(".view-header-title");
      if (!viewHeaderTitle) return;
      const icon = document.createElement("span");
      icon.classList.add("pouch-publish-status-icon");
      icon.textContent = "\u{1F4E4} ";
      icon.style.marginRight = "4px";
      icon.setAttribute("aria-label", `Published to ${frontmatter.pouch_destination}`);
      viewHeaderTitle.insertBefore(icon, viewHeaderTitle.firstChild);
    }
  }
  getSelectedDestination() {
    if (this.settings.destinations.length === 0) {
      return null;
    }
    const index = Math.min(this.settings.selectedDestinationIndex, this.settings.destinations.length - 1);
    return this.settings.destinations[index];
  }
  async publishCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file to publish");
      return;
    }
    const destination = this.getSelectedDestination();
    if (!destination) {
      new import_obsidian.Notice("Please configure at least one Pouch destination in settings");
      return;
    }
    try {
      let content = await this.app.vault.read(activeFile);
      const title = activeFile.basename;
      const slug = this.generateSlug(title);
      const filePath = activeFile.path;
      const existingPost = this.settings.publishedPosts[filePath];
      let isUpdate = false;
      if (existingPost && existingPost.filenameBase) {
        isUpdate = true;
        new import_obsidian.Notice("Updating existing post in Pouch...");
        console.log("[Pouch Publisher] Updating existing post with filename_base:", existingPost.filenameBase);
      } else {
        new import_obsidian.Notice("Publishing to Pouch...");
        console.log("[Pouch Publisher] Starting one-click publish for:", title);
      }
      let audioFilename = null;
      const audioPath = this.detectAudioFile(content);
      content = this.removeAudioEmbeds(content);
      if (audioPath) {
        new import_obsidian.Notice("Preparing audio for upload...");
        console.log("[Pouch Publisher] Detected audio file:", audioPath);
        const audioFile = await this.resolveAudioFile(audioPath, activeFile);
        if (!audioFile) {
          new ErrorModal(
            this.app,
            "Audio File Not Found",
            `Audio file not found: ${audioPath}. Please ensure the file exists in your vault.`
          ).open();
          this.addToPublishLog({
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            title,
            slug,
            url: "",
            success: false,
            errorMessage: `Audio file not found: ${audioPath}`
          });
          return;
        }
        const validation = await this.validateAudioFile(audioFile);
        if (!validation.valid) {
          new ErrorModal(this.app, "Invalid Audio File", validation.error || "Unknown validation error").open();
          this.addToPublishLog({
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            title,
            slug,
            url: "",
            success: false,
            errorMessage: validation.error
          });
          return;
        }
        try {
          audioFilename = await this.uploadAudioFile(audioFile, slug, destination);
          console.log("[Pouch Publisher] Audio uploaded, filename:", audioFilename);
        } catch (error) {
          new ErrorModal(
            this.app,
            "Audio Upload Failed",
            `Failed to upload audio: ${error.message}`
          ).open();
          this.addToPublishLog({
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            title,
            slug,
            url: "",
            success: false,
            errorMessage: `Audio upload failed: ${error.message}`
          });
          return;
        }
      }
      let editingStatus = "draft";
      if (this.settings.publishPublic) {
        editingStatus = "submission";
      } else if (this.settings.publishInternal) {
        editingStatus = "feedback";
      }
      const publishOptions = {
        title,
        slug,
        markdown: content,
        publish_internal: this.settings.publishInternal ? "1" : "0",
        publish_public: this.settings.publishPublic ? "1" : "0",
        excerpt: this.settings.publishExcerpt ? "1" : "0",
        hidden: this.settings.publishHidden ? "1" : "0",
        tags: this.settings.defaultTags,
        post_template: this.settings.defaultTemplate,
        editing_status: editingStatus,
        shortname: destination.name
        // Send shortname for API logging
      };
      if (isUpdate && existingPost.filenameBase) {
        publishOptions.filename_base = existingPost.filenameBase;
      }
      if (audioFilename) {
        publishOptions.audio_file = audioFilename;
        publishOptions.include_in_podcast = this.settings.includeInPodcast ? "1" : "0";
        publishOptions.publish_immediately = this.settings.publishImmediately ? "1" : "0";
      }
      console.log("[Pouch Publisher] Publishing with options:", publishOptions);
      const result = await this.sendToPouch(publishOptions, destination);
      if (result.success) {
        if (result.response && result.response.filename_base) {
          this.settings.publishedPosts[filePath] = {
            filePath,
            filenameBase: result.response.filename_base,
            lastPublished: (/* @__PURE__ */ new Date()).toISOString()
          };
          await this.saveSettings();
          console.log("[Pouch Publisher] Stored filename_base for future updates:", result.response.filename_base);
        }
        const url = this.getPostUrl(result.response, publishOptions, destination);
        await this.updateFrontmatter(activeFile, destination.name, url, publishOptions.editing_status);
        this.updateStatusBar(activeFile);
        this.updateFileTitle(activeFile);
        this.addToPublishLog({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          title,
          slug,
          url,
          success: true
        });
        if (audioFilename && this.settings.enableTranscription) {
          await this.triggerTranscription(audioFilename, slug, destination);
        } else if (audioFilename && !this.settings.enableTranscription) {
          new import_obsidian.Notice("Post saved! Transcription skipped as requested.");
        }
        await this.showSuccessDialog(result.response, publishOptions, destination);
      } else {
        this.addToPublishLog({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          title,
          slug,
          url: "",
          success: false,
          errorMessage: result.error
        });
      }
    } catch (error) {
      this.addToPublishLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        title: (activeFile == null ? void 0 : activeFile.basename) || "Unknown",
        slug: "",
        url: "",
        success: false,
        errorMessage: error.message
      });
      new import_obsidian.Notice(`Error publishing to Pouch: ${error.message}`);
      console.error("[Pouch Publisher] Publish error:", error);
    }
  }
  async publishWithOptions() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file to publish");
      return;
    }
    if (this.settings.destinations.length === 0) {
      new import_obsidian.Notice("Please configure at least one Pouch destination in settings");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const title = activeFile.basename;
    new PublishOptionsModal(this.app, this, activeFile, title, content).open();
  }
  /**
   * Remove audio file embeds from markdown content
   * Removes: ![[audio.mp3]] embed syntax
   * Keeps: [[audio.mp3]] wiki links and [text](audio.mp3) markdown links
   * 
   * @param content The markdown content to clean
   * @return The cleaned content with audio embeds removed
   */
  removeAudioEmbeds(content) {
    if (!this.audioEmbedPattern) {
      const extensionPattern = this.AUDIO_EXTENSIONS.join("|");
      this.audioEmbedPattern = new RegExp(`!\\[\\[([^\\]]+\\.(${extensionPattern}))\\]\\]`, "gi");
    }
    content = content.replace(this.audioEmbedPattern, "");
    this.audioEmbedPattern.lastIndex = 0;
    return content;
  }
  /**
   * Detect audio file embeds in markdown content
   * Looks for: ![[audio.mp3]], [[audio.mp3]], [text](audio.mp3)
   * Returns the first audio file path found, or null
   */
  detectAudioFile(content) {
    const extensionPattern = this.AUDIO_EXTENSIONS.join("|");
    const embedPattern = new RegExp(`!\\[\\[([^\\]]+\\.(${extensionPattern}))\\]\\]`, "i");
    let match = content.match(embedPattern);
    if (match) {
      return match[1];
    }
    const wikiPattern = new RegExp(`\\[\\[([^\\]]+\\.(${extensionPattern}))\\]\\]`, "i");
    match = content.match(wikiPattern);
    if (match) {
      return match[1];
    }
    const mdPattern = new RegExp(`\\[([^\\]]+)\\]\\(([^)]+\\.(${extensionPattern}))\\)`, "i");
    match = content.match(mdPattern);
    if (match) {
      return match[2];
    }
    return null;
  }
  /**
   * Validate audio file
   * Checks extension, MIME type, and size
   */
  async validateAudioFile(file) {
    const extension = file.extension.toLowerCase();
    if (this.VIDEO_EXTENSIONS.includes(extension)) {
      return {
        valid: false,
        error: "Video files are not allowed. Please select an audio file (e.g., MP3, WAV, M4A, OGG, FLAC)."
      };
    }
    if (!this.AUDIO_EXTENSIONS.includes(extension)) {
      return {
        valid: false,
        error: "Please select a valid audio file (e.g., MP3, WAV, M4A, OGG, FLAC)."
      };
    }
    const maxSize = 25 * 1024 * 1024;
    const stat = await this.app.vault.adapter.stat(file.path);
    if (stat && stat.size > maxSize) {
      const sizeMB = (stat.size / (1024 * 1024)).toFixed(2);
      return {
        valid: false,
        error: `File size (${sizeMB} MB) exceeds the 25 MB limit. Please select a smaller file.`
      };
    }
    return { valid: true };
  }
  /**
   * Resolve audio file path relative to the current note
   */
  async resolveAudioFile(audioPath, currentFile) {
    var _a;
    try {
      let audioFile = this.app.vault.getAbstractFileByPath(audioPath);
      if (!audioFile) {
        const currentDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
        const relativePath = currentDir ? `${currentDir}/${audioPath}` : audioPath;
        audioFile = this.app.vault.getAbstractFileByPath(relativePath);
      }
      if (audioFile instanceof import_obsidian.TFile) {
        return audioFile;
      }
      return null;
    } catch (error) {
      console.error("[Pouch Publisher] Error resolving audio file:", error);
      return null;
    }
  }
  /**
   * Upload audio file to Pouch
   * Returns the filename if successful, or throws an error
   */
  async uploadAudioFile(audioFile, slug, destination, removeSilence = false) {
    var _a;
    try {
      const audioData = await this.app.vault.readBinary(audioFile);
      const sizeMB = (audioData.byteLength / (1024 * 1024)).toFixed(2);
      new import_obsidian.Notice(`Uploading audio file (${sizeMB} MB)...`);
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "info",
        message: `Uploading audio file: ${audioFile.name} (${sizeMB} MB)`
      });
      const boundary = "----ObsidianFormBoundary" + Math.random().toString(36).substring(2);
      const parts = [];
      const addPart = (name, value) => {
        const encoder2 = new TextEncoder();
        parts.push(encoder2.encode(`--${boundary}\r
`));
        parts.push(encoder2.encode(`Content-Disposition: form-data; name="${name}"\r
\r
`));
        parts.push(encoder2.encode(`${value}\r
`));
      };
      addPart("filename_base", slug);
      addPart("api_key", destination.apiKey);
      addPart("remove_silence", removeSilence ? "true" : "false");
      const mimeType = this.MIME_TYPES[audioFile.extension.toLowerCase()] || "audio/mpeg";
      const encoder = new TextEncoder();
      parts.push(encoder.encode(`--${boundary}\r
`));
      parts.push(encoder.encode(`Content-Disposition: form-data; name="audio"; filename="${audioFile.name}"\r
`));
      parts.push(encoder.encode(`Content-Type: ${mimeType}\r
\r
`));
      parts.push(new Uint8Array(audioData));
      parts.push(encoder.encode(`\r
`));
      parts.push(encoder.encode(`--${boundary}--\r
`));
      const totalLength = parts.reduce((sum, part) => sum + part.length, 0);
      const body = new Uint8Array(totalLength);
      let offset = 0;
      for (const part of parts) {
        body.set(part, offset);
        offset += part.length;
      }
      const uploadUrl = destination.url.replace(/\/$/, "") + "/modules/audio_recording/upload_audio.php";
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "request",
        endpoint: uploadUrl,
        method: "POST",
        message: "Uploading audio to server"
      });
      const response = await (0, import_obsidian.requestUrl)({
        url: uploadUrl,
        method: "POST",
        body: body.buffer,
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        }
      });
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "response",
        endpoint: uploadUrl,
        responseStatus: response.status,
        responseBody: response.json,
        message: `Audio upload response: ${response.status}`
      });
      if (response.status === 200) {
        const result = response.json;
        if (result.success && result.filename) {
          new import_obsidian.Notice("Audio uploaded successfully. Saving post...");
          return result.filename;
        } else {
          throw new Error(result.error || "Audio upload failed");
        }
      } else {
        const errorMsg = ((_a = response.json) == null ? void 0 : _a.error) || `HTTP ${response.status}`;
        throw new Error(errorMsg);
      }
    } catch (error) {
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "error",
        errorDetails: {
          name: error.name,
          message: error.message
        },
        message: `Audio upload error: ${error.message}`
      });
      throw error;
    }
  }
  /**
   * Trigger transcription for uploaded audio
   * @param audioFilename - The filename of the uploaded audio
   * @param slug - The slug of the post
   * @param destination - The Pouch destination
   * @param aiModel - Optional AI model to use for transcript improvement (e.g., 'mistral-ai/mistral-small-2503')
   * @param aiProvider - Optional AI provider to use for transcript improvement (e.g., 'github-models')
   */
  async triggerTranscription(audioFilename, slug, destination, aiModel, aiProvider) {
    var _a, _b;
    try {
      const formData = new URLSearchParams();
      formData.append("audio_filename", audioFilename);
      formData.append("json_filename", slug + ".json");
      formData.append("api_key", destination.apiKey);
      if (aiModel) {
        formData.append("ai_model", aiModel);
      }
      if (aiProvider) {
        formData.append("ai_provider", aiProvider);
      }
      const transcribeUrl = destination.url.replace(/\/$/, "") + "/modules/transcription/trigger_transcription.php";
      const logMessage = aiModel && aiProvider ? "Triggering audio transcription with AI improvement" : "Triggering audio transcription";
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "request",
        endpoint: transcribeUrl,
        method: "POST",
        message: logMessage
      });
      const response = await (0, import_obsidian.requestUrl)({
        url: transcribeUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: formData.toString()
      });
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "response",
        endpoint: transcribeUrl,
        responseStatus: response.status,
        responseBody: response.json,
        message: `Transcription trigger response: ${response.status}`
      });
      if (response.status === 200 && ((_a = response.json) == null ? void 0 : _a.success)) {
        const noticeText = aiModel && aiProvider ? "Post saved! Transcription started with AI improvement." : "Post saved! Transcription started in background.";
        new import_obsidian.Notice(noticeText);
      } else {
        console.warn("[Pouch Publisher] Transcription trigger failed:", (_b = response.json) == null ? void 0 : _b.error);
        new import_obsidian.Notice("Post saved! Transcription may have failed to start.");
      }
    } catch (error) {
      console.warn("[Pouch Publisher] Transcription error:", error);
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "error",
        errorDetails: {
          name: error.name,
          message: error.message
        },
        message: `Transcription error: ${error.message}`
      });
    }
  }
  async sendToPouch(options, destination) {
    try {
      const formData = new URLSearchParams();
      formData.append("api_key", destination.apiKey);
      for (const key in options) {
        if (options[key] !== "" && options[key] !== void 0 && options[key] !== null) {
          formData.append(key, options[key]);
        }
      }
      console.log("[Pouch Publisher] Sending to API endpoint");
      console.log("[Pouch Publisher] API URL:", destination.url);
      console.log("[Pouch Publisher] Form data keys:", Object.keys(Object.fromEntries(formData.entries())));
      const apiUrl = destination.url.replace(/\/$/, "") + "/php/api_create_post.php";
      console.log("[Pouch Publisher] Full API URL:", apiUrl);
      const requestData = Object.fromEntries(formData.entries());
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "request",
        endpoint: apiUrl,
        method: "POST",
        requestData: this.sanitizeForLogging(requestData),
        message: "Sending API request to Pouch"
      });
      const response = await (0, import_obsidian.requestUrl)({
        url: apiUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: formData.toString()
      });
      console.log("[Pouch Publisher] API response status:", response.status);
      console.log("[Pouch Publisher] API response body:", response.json);
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "response",
        endpoint: apiUrl,
        responseStatus: response.status,
        responseBody: response.json,
        message: `Received API response with status ${response.status}`
      });
      if (response.status === 200) {
        const result = response.json;
        if (result.status === "success") {
          console.log("[Pouch Publisher] API request successful");
          this.addToDebugLog({
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            type: "info",
            message: "API request successful",
            responseBody: result
          });
          return { success: true, response: result };
        } else {
          const errorMsg = result.error || result.message || "Unknown error";
          console.error("[Pouch Publisher] API returned error status:", result.status);
          console.error("[Pouch Publisher] API error message:", errorMsg);
          this.addToDebugLog({
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            type: "error",
            responseStatus: 200,
            responseBody: result,
            message: `API returned error: ${errorMsg}`
          });
          new ErrorModal(this.app, "Publish Failed", errorMsg).open();
          return { success: false, error: errorMsg };
        }
      } else {
        const result = response.json;
        const errorMsg = result.error || result.message || `HTTP ${response.status}`;
        console.error("[Pouch Publisher] HTTP error status:", response.status);
        console.error("[Pouch Publisher] HTTP error response:", result);
        let statusCode = response.status;
        if (result.status && typeof result.status === "string" && result.status.startsWith("ERROR_")) {
          const code = parseInt(result.status.replace("ERROR_", ""));
          if (!isNaN(code)) {
            statusCode = code;
          }
        }
        this.addToDebugLog({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          type: "error",
          responseStatus: statusCode,
          responseBody: result,
          message: `HTTP error ${statusCode}: ${errorMsg}`
        });
        new ErrorModal(this.app, `Publish Failed (HTTP ${statusCode})`, errorMsg).open();
        return { success: false, error: errorMsg, statusCode };
      }
    } catch (error) {
      console.error("[Pouch Publisher] Network/request exception:", error);
      console.error("[Pouch Publisher] Exception details:", {
        name: error.name,
        message: error.message,
        stack: error.stack
      });
      this.addToDebugLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "error",
        errorDetails: {
          name: error.name,
          message: error.message,
          stack: error.stack
        },
        message: `Network/request exception: ${error.message}`
      });
      new ErrorModal(this.app, "Network Error", error.message).open();
      return { success: false, error: error.message };
    }
  }
  async showSuccessDialog(apiResponse, publishOptions, destination) {
    const url = this.getPostUrl(apiResponse, publishOptions, destination);
    const isPublic = publishOptions.publish_public === "1";
    const isHidden = publishOptions.hidden === "1";
    const urlType = isPublic ? isHidden ? "Hidden Post URL" : "Public Post URL" : "Internal Post URL";
    if (url) {
      new SuccessModal(this.app, url, urlType).open();
    } else {
      new import_obsidian.Notice("\u2713 Published successfully to Pouch!");
      console.log("[Pouch Publisher] Published successfully, no URL available");
    }
  }
  getPostUrl(apiResponse, publishOptions, destination) {
    const isPublic = publishOptions.publish_public === "1";
    const baseUrl = destination.url.replace(/\/$/, "");
    let url = "";
    if (isPublic && apiResponse.public_url) {
      url = baseUrl + apiResponse.public_url;
      console.log("[Pouch Publisher] Constructed public URL:", url);
    } else if (apiResponse.internal_url) {
      url = baseUrl + apiResponse.internal_url;
      console.log("[Pouch Publisher] Constructed internal URL:", url);
    }
    return url;
  }
  generateSlug(title) {
    return title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-/, "").replace(/-$/, "");
  }
  /**
   * Add entry to debug log if debug logging is enabled
   */
  addToDebugLog(entry) {
    if (!this.settings.enableDebugLogging) {
      return;
    }
    this.settings.debugLog.unshift(entry);
    if (this.settings.debugLog.length > 50) {
      this.settings.debugLog = this.settings.debugLog.slice(0, 50);
    }
    this.saveSettings();
    console.log("[Pouch Publisher Debug]", entry);
  }
  /**
   * Sanitize sensitive data for logging
   */
  sanitizeForLogging(data) {
    if (!data) return data;
    const sanitized = { ...data };
    if (sanitized.api_key) {
      sanitized.api_key = "[REDACTED]";
    }
    if (sanitized.content && sanitized.content.length > 500) {
      sanitized.content = sanitized.content.substring(0, 500) + `... [truncated, total length: ${sanitized.content.length}]`;
    }
    if (sanitized.markdown && sanitized.markdown.length > 500) {
      sanitized.markdown = sanitized.markdown.substring(0, 500) + `... [truncated, total length: ${sanitized.markdown.length}]`;
    }
    return sanitized;
  }
  addToPublishLog(entry) {
    this.settings.publishLog.unshift(entry);
    if (this.settings.publishLog.length > 100) {
      this.settings.publishLog = this.settings.publishLog.slice(0, 100);
    }
    this.saveSettings();
    console.log("[Pouch Publisher] Log entry added:", entry);
  }
  async updateFrontmatter(file, destinationName, url, editingStatus) {
    try {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let hasFrontmatter = false;
      let frontmatterEnd = -1;
      let newFrontmatter = [];
      if (lines[0] === "---") {
        hasFrontmatter = true;
        for (let i = 1; i < lines.length; i++) {
          if (lines[i] === "---") {
            frontmatterEnd = i;
            break;
          }
        }
      }
      if (hasFrontmatter && frontmatterEnd > 0) {
        const frontmatterLines = lines.slice(1, frontmatterEnd);
        let hasDestination = false;
        let hasUrl = false;
        let hasEditingStatus = false;
        for (const line of frontmatterLines) {
          if (line.startsWith("pouch_destination:")) {
            newFrontmatter.push(`pouch_destination: "${destinationName}"`);
            hasDestination = true;
          } else if (line.startsWith("pouch_url:")) {
            newFrontmatter.push(`pouch_url: "${url}"`);
            hasUrl = true;
          } else if (line.startsWith("editing_status:")) {
            if (editingStatus) {
              newFrontmatter.push(`editing_status: "${editingStatus}"`);
            } else {
              newFrontmatter.push(line);
            }
            hasEditingStatus = true;
          } else {
            newFrontmatter.push(line);
          }
        }
        if (!hasDestination) {
          newFrontmatter.push(`pouch_destination: "${destinationName}"`);
        }
        if (!hasUrl) {
          newFrontmatter.push(`pouch_url: "${url}"`);
        }
        if (!hasEditingStatus && editingStatus) {
          newFrontmatter.push(`editing_status: "${editingStatus}"`);
        }
        const newContent = [
          "---",
          ...newFrontmatter,
          "---",
          ...lines.slice(frontmatterEnd + 1)
        ].join("\n");
        await this.app.vault.modify(file, newContent);
      } else {
        const frontmatterLines = [
          "---",
          `pouch_destination: "${destinationName}"`,
          `pouch_url: "${url}"`
        ];
        if (editingStatus) {
          frontmatterLines.push(`editing_status: "${editingStatus}"`);
        }
        frontmatterLines.push("---");
        const newContent = [
          ...frontmatterLines,
          ...lines
        ].join("\n");
        await this.app.vault.modify(file, newContent);
      }
      console.log("[Pouch Publisher] Updated frontmatter for:", file.path);
    } catch (error) {
      console.error("[Pouch Publisher] Error updating frontmatter:", error);
      new import_obsidian.Notice("Warning: Could not update frontmatter");
    }
  }
  onunload() {
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    if (this.settings.pouchUrl && this.settings.apiKey) {
      if (this.settings.destinations.length === 0) {
        this.settings.destinations.push({
          name: "default",
          url: this.settings.pouchUrl,
          apiKey: this.settings.apiKey,
          magazineMode: false
        });
        this.settings.selectedDestinationIndex = 0;
        delete this.settings.pouchUrl;
        delete this.settings.apiKey;
        await this.saveSettings();
        console.log("[Pouch Publisher] Migrated legacy settings to destinations");
      }
    }
    let needsSave = false;
    this.settings.destinations.forEach((dest) => {
      if (dest.magazineMode === void 0) {
        dest.magazineMode = false;
        needsSave = true;
      }
    });
    if (needsSave) {
      await this.saveSettings();
      console.log("[Pouch Publisher] Added magazineMode property to existing destinations");
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
// AI transcript improvement defaults (matching Pouch server defaults)
PouchPublisherPlugin.DEFAULT_AI_MODEL = "mistral-ai/mistral-small-2503";
PouchPublisherPlugin.DEFAULT_AI_PROVIDER = "github-models";
var PublishOptionsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, file, title, content) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    this.title = title;
    this.content = content;
    const existingPost = plugin.settings.publishedPosts[file.path];
    this.existingFilenameBase = (existingPost == null ? void 0 : existingPost.filenameBase) || null;
    this.slug = this.plugin.generateSlug(title);
    this.tags = plugin.settings.defaultTags;
    this.template = plugin.settings.defaultTemplate;
    this.publishInternal = plugin.settings.publishInternal;
    this.publishPublic = plugin.settings.publishPublic;
    this.publishExcerpt = plugin.settings.publishExcerpt;
    this.publishHidden = plugin.settings.publishHidden;
    this.rememberSettings = plugin.settings.rememberSettings;
    this.selectedDestinationIndex = plugin.settings.selectedDestinationIndex;
    this.includeInPodcast = plugin.settings.includeInPodcast;
    this.publishImmediately = plugin.settings.publishImmediately;
    this.enableTranscription = plugin.settings.enableTranscription;
    this.improveTranscriptWithAI = false;
    this.removeSilence = false;
    this.hasAudioFile = plugin.detectAudioFile(content) !== null;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (frontmatter && frontmatter.editing_status) {
      const status = frontmatter.editing_status;
      if (status === "draft" || status === "feedback" || status === "submission") {
        this.editingStatus = status;
      } else {
        this.editingStatus = "draft";
      }
    } else {
      this.editingStatus = "draft";
    }
    this.initialEditingStatus = this.editingStatus;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    const isUpdate = this.existingFilenameBase !== null;
    const headerText = isUpdate ? "Update Post in Pouch" : "Publish to Pouch";
    contentEl.createEl("h2", { text: headerText });
    contentEl.createEl("p", { text: `${isUpdate ? "Updating" : "Publishing"}: ${this.title}`, cls: "pouch-publish-title" });
    if (isUpdate) {
      contentEl.createEl("p", { text: "This note has been published before and will be updated.", cls: "pouch-update-notice" });
    }
    const formEl = contentEl.createDiv({ cls: "pouch-publish-form" });
    if (this.plugin.settings.destinations.length > 1) {
      new import_obsidian.Setting(formEl).setName("Publishing Destination").setDesc("Select where to publish this post").addDropdown((dropdown) => {
        this.plugin.settings.destinations.forEach((dest, index) => {
          dropdown.addOption(index.toString(), `${dest.name} (${dest.url})`);
        });
        dropdown.setValue(this.selectedDestinationIndex.toString());
        dropdown.onChange((value) => {
          this.selectedDestinationIndex = parseInt(value);
          this.onOpen();
        });
      });
    } else if (this.plugin.settings.destinations.length === 1) {
      const dest = this.plugin.settings.destinations[0];
      new import_obsidian.Setting(formEl).setName("Publishing Destination").setDesc(`${dest.name} (${dest.url})`).setDisabled(true);
    }
    new import_obsidian.Setting(formEl).setName("Post Slug").setDesc("URL-friendly identifier for this post").addText((text) => text.setValue(this.slug).onChange((value) => {
      this.slug = value;
    }));
    new import_obsidian.Setting(formEl).setName("Tags").setDesc("Comma-separated tags").addText((text) => text.setValue(this.tags).setPlaceholder("tag1, tag2, tag3").onChange((value) => {
      this.tags = value;
    }));
    new import_obsidian.Setting(formEl).setName("Custom Template").setDesc("Optional custom Pouch template name").addText((text) => text.setValue(this.template).setPlaceholder("post_custom").onChange((value) => {
      this.template = value;
    }));
    formEl.createEl("h3", { text: "Publishing Options" });
    const selectedDestination = this.plugin.settings.destinations[this.selectedDestinationIndex];
    const isMagazineMode = (selectedDestination == null ? void 0 : selectedDestination.magazineMode) || false;
    if (isMagazineMode) {
      const statusDiv = formEl.createDiv({ cls: "pouch-magazine-status" });
      statusDiv.createEl("p", { text: "Editing Status:", cls: "pouch-status-label" });
      const statusButtonsDiv = statusDiv.createDiv({ cls: "pouch-status-buttons" });
      const handleStatusClick = async (newStatus) => {
        if (this.initialEditingStatus === "submission" && newStatus !== "submission") {
          const confirmed = await this.confirmStatusChange(newStatus);
          if (!confirmed) return;
        }
        this.editingStatus = newStatus;
        this.updateStatusButtons(statusButtonsDiv);
      };
      const draftBtn = statusButtonsDiv.createEl("button", {
        text: "Draft",
        cls: "pouch-status-btn" + (this.editingStatus === "draft" ? " pouch-status-active" : "")
      });
      draftBtn.type = "button";
      draftBtn.addEventListener("click", () => handleStatusClick("draft"));
      const feedbackBtn = statusButtonsDiv.createEl("button", {
        text: "Feedback",
        cls: "pouch-status-btn" + (this.editingStatus === "feedback" ? " pouch-status-active" : "")
      });
      feedbackBtn.type = "button";
      feedbackBtn.addEventListener("click", () => handleStatusClick("feedback"));
      const submissionBtn = statusButtonsDiv.createEl("button", {
        text: "Submission",
        cls: "pouch-status-btn" + (this.editingStatus === "submission" ? " pouch-status-active" : "")
      });
      submissionBtn.type = "button";
      submissionBtn.addEventListener("click", () => handleStatusClick("submission"));
      const statusDesc = statusDiv.createEl("p", { cls: "pouch-status-desc" });
      statusDesc.innerHTML = `
				<strong>Draft:</strong> Work in progress, visible only to you.<br>
				<strong>Feedback:</strong> Visible to other writers for discussion (not public).<br>
				<strong>Submission:</strong> Request to editor/admin to publish publicly.
			`;
    }
    const internalSetting = new import_obsidian.Setting(formEl).setName("Internal Post").setDesc("Make visible to logged-in users").addToggle((toggle) => toggle.setValue(this.publishInternal).onChange((value) => {
      this.publishInternal = value;
    }));
    if (isMagazineMode) {
      internalSetting.settingEl.style.display = "none";
    }
    const publicSetting = new import_obsidian.Setting(formEl).setName("Public Post").setDesc("Make visible to everyone").addToggle((toggle) => toggle.setValue(this.publishPublic).onChange((value) => {
      this.publishPublic = value;
      this.updatePublicOptions();
    }));
    if (isMagazineMode) {
      publicSetting.settingEl.style.display = "none";
    }
    let excerptToggle;
    const excerptSetting = new import_obsidian.Setting(formEl).setName("Excerpt").setDesc("Show only first 50 words publicly").addToggle((toggle) => {
      excerptToggle = toggle;
      toggle.setValue(this.publishExcerpt).onChange((value) => {
        this.publishExcerpt = value;
        if (value && this.publishHidden) {
          this.publishHidden = false;
          hiddenToggle.setValue(false);
        }
      });
    });
    excerptSetting.settingEl.addClass("pouch-public-option");
    let hiddenToggle;
    const hiddenSetting = new import_obsidian.Setting(formEl).setName("Hidden").setDesc("Exclude from public lists and RSS (shareable via URL)").addToggle((toggle) => {
      hiddenToggle = toggle;
      toggle.setValue(this.publishHidden).onChange((value) => {
        this.publishHidden = value;
        if (value && this.publishExcerpt) {
          this.publishExcerpt = false;
          excerptToggle.setValue(false);
        }
      });
    });
    hiddenSetting.settingEl.addClass("pouch-public-option");
    new import_obsidian.Setting(formEl).setName("Remember Settings").setDesc("Save these settings for future one-click publishing (except title and slug)").addToggle((toggle) => toggle.setValue(this.rememberSettings).onChange((value) => {
      this.rememberSettings = value;
    }));
    if (this.hasAudioFile) {
      formEl.createEl("h3", { text: "Audio Options" });
      formEl.createEl("p", { text: "Audio file detected in this note.", cls: "pouch-audio-detected" });
      new import_obsidian.Setting(formEl).setName("Include in Podcast RSS Feed").setDesc("Add this audio post to your podcast RSS feed (internal and/or public)").addToggle((toggle) => toggle.setValue(this.includeInPodcast).onChange((value) => {
        this.includeInPodcast = value;
      }));
      new import_obsidian.Setting(formEl).setName("Publish Immediately").setDesc("Automatically inserts intro and outro clips and publishes as a podcast episode. You can still edit the episode later.").addToggle((toggle) => toggle.setValue(this.publishImmediately).onChange((value) => {
        this.publishImmediately = value;
      }));
      new import_obsidian.Setting(formEl).setName("Remove Silence").setDesc("Automatically remove silence from the beginning and end of the audio").addToggle((toggle) => toggle.setValue(this.removeSilence).onChange((value) => {
        this.removeSilence = value;
      }));
      let improveAiSetting = null;
      let privacyNoticeEl = null;
      const transcriptionSetting = new import_obsidian.Setting(formEl).setName("Skip Transcription").setDesc("Do not transcribe this audio (transcription is done locally on the server)").addToggle((toggle) => toggle.setValue(!this.enableTranscription).onChange((value) => {
        this.enableTranscription = !value;
        if (improveAiSetting) {
          if (value) {
            improveAiSetting.settingEl.style.display = "none";
            if (privacyNoticeEl) privacyNoticeEl.style.display = "none";
            this.improveTranscriptWithAI = false;
          } else {
            improveAiSetting.settingEl.style.display = "";
            if (privacyNoticeEl) privacyNoticeEl.style.display = "";
          }
        }
      }));
      improveAiSetting = new import_obsidian.Setting(formEl).setName("Improve Transcript with AI").setDesc("Use an external AI service to improve transcript formatting, spelling and grammar").addToggle((toggle) => toggle.setValue(this.improveTranscriptWithAI).onChange((value) => {
        this.improveTranscriptWithAI = value;
      }));
      improveAiSetting.settingEl.addClass("pouch-ai-transcript-option");
      privacyNoticeEl = formEl.createDiv({ cls: "pouch-privacy-notice" });
      privacyNoticeEl.createEl("strong", { text: "Privacy notice:" });
      privacyNoticeEl.appendText(" This service requires sending the transcript text of your recording (not your audio) to an external service to improve readability, spelling and grammar. This may send your text to a service located in the USA (Microsoft Azure, or Ollama Cloud). See our ");
      const privacyLink = privacyNoticeEl.createEl("a", { text: "privacy policy" });
      const currentDestination = this.plugin.settings.destinations[this.selectedDestinationIndex];
      const destinationUrl = ((_a = currentDestination == null ? void 0 : currentDestination.url) == null ? void 0 : _a.replace(/\/$/, "")) || "";
      privacyLink.href = destinationUrl ? `${destinationUrl}/legal/privacy.html` : "/legal/privacy.html";
      privacyLink.target = "_blank";
      privacyLink.rel = "noopener noreferrer";
      privacyNoticeEl.appendText(" for details.");
      if (!this.enableTranscription) {
        improveAiSetting.settingEl.style.display = "none";
        privacyNoticeEl.style.display = "none";
      }
    }
    this.updatePublicOptions();
    const buttonDiv = contentEl.createDiv({ cls: "pouch-publish-buttons" });
    const publishButton = buttonDiv.createEl("button", { text: isUpdate ? "Update" : "Publish", cls: "mod-cta" });
    publishButton.addEventListener("click", async () => {
      await this.handlePublish();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    contentEl.createEl("style", {
      text: `
				.pouch-publish-form { margin: 1em 0; }
				.pouch-publish-title { color: var(--text-muted); font-size: 0.9em; }
				.pouch-update-notice { color: var(--text-accent); font-size: 0.9em; font-style: italic; margin-top: 0.5em; }
				.pouch-publish-buttons { display: flex; gap: 0.5em; justify-content: flex-end; margin-top: 1em; }
				.pouch-publish-buttons button { padding: 0.5em 1em; }
				.pouch-public-option { margin-left: 1.5em; }
				.pouch-public-option-hidden { display: none; }
				.pouch-magazine-status { margin-bottom: 1.5em; }
				.pouch-status-label { font-weight: 600; margin-bottom: 0.5em; }
				.pouch-status-buttons { display: flex; gap: 0.5em; margin-bottom: 1em; }
				.pouch-status-btn { padding: 0.5em 1em; border: 1px solid var(--background-modifier-border); background: var(--background-secondary); cursor: pointer; }
				.pouch-status-btn:hover { background: var(--background-modifier-hover); }
				.pouch-status-btn.pouch-status-active { background: var(--interactive-accent); color: var(--text-on-accent); border-color: var(--interactive-accent); }
				.pouch-status-desc { font-size: 0.85em; color: var(--text-muted); line-height: 1.6; }
				.pouch-audio-detected { color: var(--text-accent); font-size: 0.9em; margin-bottom: 0.5em; }
				.pouch-ai-transcript-option { margin-left: 1.5em; }
				.pouch-privacy-notice { margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 1em; padding: 0.75em; background: var(--background-secondary); border-radius: 4px; font-size: 0.85em; color: var(--text-muted); line-height: 1.5; border-left: 3px solid var(--interactive-accent); }
				.pouch-privacy-notice a { color: var(--text-accent); font-weight: 600; }
			`
    });
  }
  updatePublicOptions() {
    const publicOptions = this.contentEl.querySelectorAll(".pouch-public-option");
    publicOptions.forEach((el) => {
      if (this.publishPublic) {
        el.removeClass("pouch-public-option-hidden");
      } else {
        el.addClass("pouch-public-option-hidden");
      }
    });
  }
  updateStatusButtons(container) {
    const buttons = container.querySelectorAll(".pouch-status-btn");
    buttons.forEach((btn) => {
      var _a;
      const buttonEl = btn;
      const status = (_a = buttonEl.textContent) == null ? void 0 : _a.toLowerCase();
      if (status === this.editingStatus) {
        buttonEl.addClass("pouch-status-active");
      } else {
        buttonEl.removeClass("pouch-status-active");
      }
    });
  }
  async confirmStatusChange(newStatus) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Confirm Status Change");
      const message = modal.contentEl.createDiv();
      message.createEl("p", {
        text: `You are about to change the status from "Submission" to "${newStatus === "draft" ? "Draft" : "Feedback"}".`
      });
      message.createEl("p", {
        text: "This will unpublish the post if it was public. The post will be removed from public view.",
        cls: "pouch-warning-text"
      });
      message.createEl("p", {
        text: "Are you sure you want to continue?"
      });
      const buttonDiv = modal.contentEl.createDiv({ cls: "pouch-confirm-buttons" });
      const confirmBtn = buttonDiv.createEl("button", { text: "Yes, Change Status", cls: "mod-warning" });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      const cancelBtn = buttonDiv.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      modal.contentEl.createEl("style", {
        text: `
					.pouch-warning-text {
						color: var(--text-error);
						font-weight: 600;
					}
					.pouch-confirm-buttons {
						display: flex;
						gap: 0.5em;
						justify-content: flex-end;
						margin-top: 1em;
					}
					.pouch-confirm-buttons button {
						padding: 0.5em 1em;
					}
				`
      });
      modal.open();
    });
  }
  async handlePublish() {
    const isUpdate = this.existingFilenameBase !== null;
    console.log("[Pouch Publisher] Publishing with options from modal, isUpdate:", isUpdate);
    if (this.publishExcerpt && this.publishHidden) {
      new import_obsidian.Notice("Error: Excerpt and Hidden cannot both be enabled");
      return;
    }
    const destination = this.plugin.settings.destinations[this.selectedDestinationIndex];
    if (!destination) {
      new import_obsidian.Notice("Error: Invalid destination selected");
      return;
    }
    new import_obsidian.Notice(isUpdate ? "Updating post in Pouch..." : "Publishing to Pouch...");
    if (this.rememberSettings) {
      this.plugin.settings.publishInternal = this.publishInternal;
      this.plugin.settings.publishPublic = this.publishPublic;
      this.plugin.settings.publishExcerpt = this.publishExcerpt;
      this.plugin.settings.publishHidden = this.publishHidden;
      this.plugin.settings.defaultTags = this.tags;
      this.plugin.settings.defaultTemplate = this.template;
      this.plugin.settings.rememberSettings = this.rememberSettings;
      this.plugin.settings.selectedDestinationIndex = this.selectedDestinationIndex;
      await this.plugin.saveSettings();
      console.log("[Pouch Publisher] Settings saved for future use");
    }
    let audioFilename = null;
    const audioPath = this.plugin.detectAudioFile(this.content);
    const cleanedContent = this.plugin.removeAudioEmbeds(this.content);
    if (audioPath) {
      new import_obsidian.Notice("Preparing audio for upload...");
      console.log("[Pouch Publisher] Detected audio file:", audioPath);
      const audioFile = await this.plugin.resolveAudioFile(audioPath, this.file);
      if (!audioFile) {
        new ErrorModal(
          this.app,
          "Audio File Not Found",
          `Audio file not found: ${audioPath}. Please ensure the file exists in your vault.`
        ).open();
        this.plugin.addToPublishLog({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          title: this.title,
          slug: this.slug,
          url: "",
          success: false,
          errorMessage: `Audio file not found: ${audioPath}`
        });
        return;
      }
      const validation = await this.plugin.validateAudioFile(audioFile);
      if (!validation.valid) {
        new ErrorModal(this.app, "Invalid Audio File", validation.error || "Unknown validation error").open();
        this.plugin.addToPublishLog({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          title: this.title,
          slug: this.slug,
          url: "",
          success: false,
          errorMessage: validation.error
        });
        return;
      }
      try {
        audioFilename = await this.plugin.uploadAudioFile(audioFile, this.slug, destination, this.removeSilence);
        console.log("[Pouch Publisher] Audio uploaded, filename:", audioFilename);
      } catch (error) {
        new ErrorModal(
          this.app,
          "Audio Upload Failed",
          `Failed to upload audio: ${error.message}`
        ).open();
        this.plugin.addToPublishLog({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          title: this.title,
          slug: this.slug,
          url: "",
          success: false,
          errorMessage: `Audio upload failed: ${error.message}`
        });
        return;
      }
    }
    const publishOptions = {
      title: this.title,
      slug: this.slug,
      markdown: cleanedContent,
      publish_internal: this.publishInternal ? "1" : "0",
      publish_public: this.publishPublic ? "1" : "0",
      excerpt: this.publishExcerpt ? "1" : "0",
      hidden: this.publishHidden ? "1" : "0",
      tags: this.tags,
      post_template: this.template,
      editing_status: this.editingStatus,
      shortname: destination.name
      // Send shortname for API logging
    };
    if (isUpdate && this.existingFilenameBase) {
      publishOptions.filename_base = this.existingFilenameBase;
      console.log("[Pouch Publisher] Including filename_base for update:", this.existingFilenameBase);
    }
    if (audioFilename) {
      publishOptions.audio_file = audioFilename;
      publishOptions.include_in_podcast = this.includeInPodcast ? "1" : "0";
      publishOptions.publish_immediately = this.publishImmediately ? "1" : "0";
    }
    console.log("[Pouch Publisher] Publishing with options:", publishOptions);
    const result = await this.plugin.sendToPouch(publishOptions, destination);
    if (result.success) {
      if (result.response && result.response.filename_base) {
        this.plugin.settings.publishedPosts[this.file.path] = {
          filePath: this.file.path,
          filenameBase: result.response.filename_base,
          lastPublished: (/* @__PURE__ */ new Date()).toISOString()
        };
        await this.plugin.saveSettings();
        console.log("[Pouch Publisher] Stored filename_base for future updates:", result.response.filename_base);
      }
      const url = this.plugin.getPostUrl(result.response, publishOptions, destination);
      await this.plugin.updateFrontmatter(this.file, destination.name, url, publishOptions.editing_status);
      this.plugin.updateStatusBar(this.file);
      this.plugin.updateFileTitle(this.file);
      this.plugin.addToPublishLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        title: this.title,
        slug: this.slug,
        url,
        success: true
      });
      if (audioFilename && this.enableTranscription) {
        const aiModel = this.improveTranscriptWithAI ? PouchPublisherPlugin.DEFAULT_AI_MODEL : void 0;
        const aiProvider = this.improveTranscriptWithAI ? PouchPublisherPlugin.DEFAULT_AI_PROVIDER : void 0;
        await this.plugin.triggerTranscription(audioFilename, this.slug, destination, aiModel, aiProvider);
      } else if (audioFilename && !this.enableTranscription) {
        new import_obsidian.Notice("Post saved! Transcription skipped as requested.");
      }
      this.displaySuccessMessage(url, publishOptions);
    } else {
      this.plugin.addToPublishLog({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        title: this.title,
        slug: this.slug,
        url: "",
        success: false,
        errorMessage: result.error
      });
    }
  }
  displaySuccessMessage(url, publishOptions) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u2713 Published Successfully!" });
    const isPublic = publishOptions.publish_public === "1";
    const isHidden = publishOptions.hidden === "1";
    const urlType = isPublic ? isHidden ? "Hidden Post URL" : "Public Post URL" : "Internal Post URL";
    contentEl.createEl("p", { text: `Published: ${this.title}`, cls: "pouch-publish-title" });
    if (url) {
      contentEl.createEl("p", { text: urlType });
      const urlDiv = contentEl.createDiv({ cls: "pouch-success-url" });
      urlDiv.createEl("code", { text: url });
      const buttonDiv = contentEl.createDiv({ cls: "pouch-success-buttons" });
      const visitButton = buttonDiv.createEl("button", { text: "Visit Post", cls: "mod-cta" });
      visitButton.addEventListener("click", () => {
        window.open(url, "_blank");
      });
      const copyButton = buttonDiv.createEl("button", { text: "Copy URL" });
      copyButton.addEventListener("click", async () => {
        await this.copyToClipboard(url);
      });
      const closeButton = buttonDiv.createEl("button", { text: "Close" });
      closeButton.addEventListener("click", () => {
        this.close();
      });
    } else {
      const closeButton = contentEl.createEl("button", { text: "Close", cls: "mod-cta" });
      closeButton.addEventListener("click", () => {
        this.close();
      });
    }
    contentEl.createEl("style", {
      text: `
				.pouch-publish-title { color: var(--text-muted); font-size: 0.9em; }
				.pouch-success-url { 
					background: var(--background-secondary); 
					padding: 1em; 
					border-radius: 4px; 
					margin: 1em 0;
					word-break: break-all;
				}
				.pouch-success-url code { 
					font-size: 0.9em; 
					color: var(--text-normal);
				}
				.pouch-success-buttons { 
					display: flex; 
					gap: 0.5em; 
					justify-content: flex-end; 
					margin-top: 1em; 
				}
				.pouch-success-buttons button { 
					padding: 0.5em 1em; 
				}
			`
    });
  }
  async copyToClipboard(text) {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        new import_obsidian.Notice("URL copied to clipboard!");
        console.log("[Pouch Publisher] URL copied using Clipboard API");
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
          const successful = document.execCommand("copy");
          if (successful) {
            new import_obsidian.Notice("URL copied to clipboard!");
            console.log("[Pouch Publisher] URL copied using execCommand");
          } else {
            throw new Error("execCommand failed");
          }
        } catch (err) {
          new import_obsidian.Notice("Failed to copy URL. Please copy manually.");
          console.error("[Pouch Publisher] Copy failed:", err);
        }
        document.body.removeChild(textArea);
      }
    } catch (err) {
      new import_obsidian.Notice("Failed to copy URL. Please copy manually.");
      console.error("[Pouch Publisher] Copy error:", err);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ErrorModal = class extends import_obsidian.Modal {
  constructor(app, title, errorMessage) {
    super(app);
    this.title = title;
    this.errorMessage = errorMessage;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `\u26A0\uFE0F ${this.title}` });
    const errorDiv = contentEl.createDiv({ cls: "pouch-error-message" });
    errorDiv.createEl("p", { text: this.errorMessage });
    const buttonDiv = contentEl.createDiv({ cls: "pouch-error-buttons" });
    const closeButton = buttonDiv.createEl("button", { text: "Close", cls: "mod-cta" });
    closeButton.addEventListener("click", () => {
      this.close();
    });
    contentEl.createEl("style", {
      text: `
				.pouch-error-message { 
					background: var(--background-secondary); 
					padding: 1em; 
					border-radius: 4px; 
					margin: 1em 0;
					border-left: 3px solid var(--text-error);
				}
				.pouch-error-message p { 
					color: var(--text-error);
					margin: 0;
					word-wrap: break-word;
				}
				.pouch-error-buttons { 
					display: flex; 
					gap: 0.5em; 
					justify-content: flex-end; 
					margin-top: 1em; 
				}
				.pouch-error-buttons button { 
					padding: 0.5em 1em; 
				}
			`
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SuccessModal = class extends import_obsidian.Modal {
  constructor(app, url, urlType) {
    super(app);
    this.url = url;
    this.urlType = urlType;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u2713 Published Successfully!" });
    contentEl.createEl("p", { text: this.urlType });
    const urlDiv = contentEl.createDiv({ cls: "pouch-success-url" });
    urlDiv.createEl("code", { text: this.url });
    const buttonDiv = contentEl.createDiv({ cls: "pouch-success-buttons" });
    const visitButton = buttonDiv.createEl("button", { text: "Visit Post", cls: "mod-cta" });
    visitButton.addEventListener("click", () => {
      window.open(this.url, "_blank");
    });
    const copyButton = buttonDiv.createEl("button", { text: "Copy URL" });
    copyButton.addEventListener("click", async () => {
      await this.copyToClipboard(this.url);
    });
    const closeButton = buttonDiv.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => {
      this.close();
    });
    contentEl.createEl("style", {
      text: `
				.pouch-success-url { 
					background: var(--background-secondary); 
					padding: 1em; 
					border-radius: 4px; 
					margin: 1em 0;
					word-break: break-all;
				}
				.pouch-success-url code { 
					font-size: 0.9em; 
					color: var(--text-normal);
				}
				.pouch-success-buttons { 
					display: flex; 
					gap: 0.5em; 
					justify-content: flex-end; 
					margin-top: 1em; 
				}
				.pouch-success-buttons button { 
					padding: 0.5em 1em; 
				}
			`
    });
  }
  async copyToClipboard(text) {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        new import_obsidian.Notice("URL copied to clipboard!");
        console.log("[Pouch Publisher] URL copied using Clipboard API");
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
          const successful = document.execCommand("copy");
          if (successful) {
            new import_obsidian.Notice("URL copied to clipboard!");
            console.log("[Pouch Publisher] URL copied using execCommand");
          } else {
            throw new Error("execCommand failed");
          }
        } catch (err) {
          new import_obsidian.Notice("Failed to copy URL. Please copy manually.");
          console.error("[Pouch Publisher] Copy failed:", err);
        }
        document.body.removeChild(textArea);
      }
    } catch (err) {
      new import_obsidian.Notice("Failed to copy URL. Please copy manually.");
      console.error("[Pouch Publisher] Copy error:", err);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PouchPublisherSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Pouch Publisher Settings" });
    containerEl.createEl("h3", { text: "Publishing Destinations" });
    containerEl.createEl("p", {
      text: "Configure up to 5 Pouch destinations. Each destination requires a shortname (max 7 characters, no spaces), URL, and API key.",
      cls: "setting-item-description"
    });
    this.plugin.settings.destinations.forEach((dest, index) => {
      const destContainer = containerEl.createDiv({ cls: "pouch-destination-container" });
      const destHeader = destContainer.createEl("h4", { text: `Destination ${index + 1}: ${dest.name}` });
      new import_obsidian.Setting(destContainer).setName("Shortname").setDesc("Max 7 characters, no spaces").addText((text) => text.setPlaceholder("default").setValue(dest.name).onChange(async (value) => {
        const sanitized = value.replace(/\s+/g, "").substring(0, 7);
        if (sanitized !== value) {
          text.setValue(sanitized);
        }
        dest.name = sanitized;
        await this.plugin.saveSettings();
        destHeader.setText(`Destination ${index + 1}: ${sanitized}`);
      }));
      new import_obsidian.Setting(destContainer).setName("Pouch URL").setDesc("Your Pouch instance URL").addText((text) => text.setPlaceholder("https://your-pouch-domain.com").setValue(dest.url).onChange(async (value) => {
        dest.url = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(destContainer).setName("API Key").setDesc("Your Pouch API key").addText((text) => text.setPlaceholder("Enter your API key").setValue(dest.apiKey).onChange(async (value) => {
        dest.apiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(destContainer).setName("Magazine Mode").setDesc("Enable magazine mode for this destination (shows Feedback and Submission editing states)").addToggle((toggle) => toggle.setValue(dest.magazineMode || false).onChange(async (value) => {
        dest.magazineMode = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(destContainer).setName("Remove Destination").setDesc("Delete this publishing destination").addButton((button) => button.setButtonText("Remove").setWarning().onClick(async () => {
        this.plugin.settings.destinations.splice(index, 1);
        if (this.plugin.settings.selectedDestinationIndex >= this.plugin.settings.destinations.length) {
          this.plugin.settings.selectedDestinationIndex = Math.max(0, this.plugin.settings.destinations.length - 1);
        }
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    if (this.plugin.settings.destinations.length < 5) {
      new import_obsidian.Setting(containerEl).setName("Add New Destination").setDesc(`Add another Pouch destination (${this.plugin.settings.destinations.length}/5)`).addButton((button) => button.setButtonText("Add Destination").setCta().onClick(async () => {
        this.plugin.settings.destinations.push({
          name: `dest${this.plugin.settings.destinations.length + 1}`,
          url: "",
          apiKey: "",
          magazineMode: false
        });
        await this.plugin.saveSettings();
        this.display();
      }));
    } else {
      containerEl.createEl("p", {
        text: "Maximum of 5 destinations reached.",
        cls: "setting-item-description"
      });
    }
    containerEl.createEl("p", {
      text: "To get your API key, log into your Pouch instance and navigate to Settings or API Keys section.",
      cls: "setting-item-description"
    });
    containerEl.createEl("h3", { text: "Ribbon Icons" });
    new import_obsidian.Setting(containerEl).setName("Show One-Click Publishing Icon").setDesc("Display the cloud upload icon in the sidebar ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.showOneClickIcon).onChange(async (value) => {
      this.plugin.settings.showOneClickIcon = value;
      await this.plugin.saveSettings();
      this.plugin.updateRibbonIcons();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Publishing with Options Icon").setDesc("Display the settings icon in the sidebar ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.showOptionsIcon).onChange(async (value) => {
      this.plugin.settings.showOptionsIcon = value;
      await this.plugin.saveSettings();
      this.plugin.updateRibbonIcons();
    }));
    containerEl.createEl("h3", { text: "Audio File Settings" });
    new import_obsidian.Setting(containerEl).setName("Include in Podcast by Default").setDesc("Automatically include audio posts in podcast RSS feed").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeInPodcast).onChange(async (value) => {
      this.plugin.settings.includeInPodcast = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Publish Immediately by Default").setDesc("Automatically generate and publish podcast episodes with intro/outro clips").addToggle((toggle) => toggle.setValue(this.plugin.settings.publishImmediately).onChange(async (value) => {
      this.plugin.settings.publishImmediately = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Transcription").setDesc("Automatically transcribe uploaded audio files").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTranscription).onChange(async (value) => {
      this.plugin.settings.enableTranscription = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Publishing Log" });
    const logDesc = containerEl.createEl("p", {
      text: "Recent publishing activity (most recent first):",
      cls: "setting-item-description"
    });
    if (this.plugin.settings.publishLog.length === 0) {
      containerEl.createEl("p", {
        text: "No publishing activity yet.",
        cls: "pouch-log-empty"
      });
    } else {
      const logContainer = containerEl.createDiv({ cls: "pouch-log-container" });
      this.plugin.settings.publishLog.forEach((entry, index) => {
        const logEntry = logContainer.createDiv({ cls: "pouch-log-entry" });
        const timestamp = new Date(entry.timestamp);
        const formattedTime = timestamp.toLocaleString();
        if (entry.success) {
          logEntry.addClass("pouch-log-success");
          logEntry.createEl("div", {
            text: `\u2713 ${formattedTime}`,
            cls: "pouch-log-timestamp"
          });
          logEntry.createEl("div", {
            text: `Title: ${entry.title}`,
            cls: "pouch-log-title"
          });
          logEntry.createEl("div", {
            text: `Slug: ${entry.slug}`,
            cls: "pouch-log-slug"
          });
          if (entry.url) {
            const urlDiv = logEntry.createDiv({ cls: "pouch-log-url" });
            const urlLink = urlDiv.createEl("a", {
              text: entry.url,
              href: entry.url
            });
            urlLink.setAttribute("target", "_blank");
          }
        } else {
          logEntry.addClass("pouch-log-error");
          logEntry.createEl("div", {
            text: `\u2717 ${formattedTime}`,
            cls: "pouch-log-timestamp"
          });
          logEntry.createEl("div", {
            text: `Title: ${entry.title}`,
            cls: "pouch-log-title"
          });
          if (entry.slug) {
            logEntry.createEl("div", {
              text: `Slug: ${entry.slug}`,
              cls: "pouch-log-slug"
            });
          }
          if (entry.errorMessage) {
            logEntry.createEl("div", {
              text: `Error: ${entry.errorMessage}`,
              cls: "pouch-log-error-msg"
            });
          }
        }
      });
      new import_obsidian.Setting(containerEl).setName("Clear Log").setDesc("Remove all entries from the publishing log").addButton((button) => button.setButtonText("Clear Log").setWarning().onClick(async () => {
        this.plugin.settings.publishLog = [];
        await this.plugin.saveSettings();
        this.display();
      }));
    }
    containerEl.createEl("h3", { text: "Debug Logging" });
    new import_obsidian.Setting(containerEl).setName("Enable Debug Logging").setDesc("Enable detailed logging of API requests and responses for troubleshooting. Logs are stored locally in the plugin settings.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDebugLogging).onChange(async (value) => {
      this.plugin.settings.enableDebugLogging = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableDebugLogging) {
      const debugLogDesc = containerEl.createEl("p", {
        text: "Debug log entries (most recent first):",
        cls: "setting-item-description"
      });
      if (this.plugin.settings.debugLog.length === 0) {
        containerEl.createEl("p", {
          text: "No debug log entries yet. Perform an API action to see logs here.",
          cls: "pouch-log-empty"
        });
      } else {
        const debugLogContainer = containerEl.createDiv({ cls: "pouch-debug-log-container" });
        this.plugin.settings.debugLog.forEach((entry, index) => {
          const logEntry = debugLogContainer.createDiv({ cls: "pouch-debug-log-entry" });
          logEntry.addClass(`pouch-debug-${entry.type}`);
          const timestamp = new Date(entry.timestamp);
          const formattedTime = timestamp.toLocaleString();
          const headerDiv = logEntry.createDiv({ cls: "pouch-debug-header" });
          headerDiv.createEl("span", {
            text: `[${entry.type.toUpperCase()}] ${formattedTime}`,
            cls: "pouch-debug-timestamp"
          });
          logEntry.createEl("div", {
            text: entry.message,
            cls: "pouch-debug-message"
          });
          if (entry.endpoint) {
            logEntry.createEl("div", {
              text: `Endpoint: ${entry.endpoint}`,
              cls: "pouch-debug-detail"
            });
          }
          if (entry.method) {
            logEntry.createEl("div", {
              text: `Method: ${entry.method}`,
              cls: "pouch-debug-detail"
            });
          }
          if (entry.responseStatus) {
            logEntry.createEl("div", {
              text: `Status: ${entry.responseStatus}`,
              cls: "pouch-debug-detail"
            });
          }
          if (entry.requestData) {
            const requestToggle = logEntry.createDiv({ cls: "pouch-debug-toggle" });
            requestToggle.createEl("span", { text: "\u25B6 Show Request Data" });
            const requestData = logEntry.createEl("pre", {
              text: JSON.stringify(entry.requestData, null, 2),
              cls: "pouch-debug-json"
            });
            requestData.style.display = "none";
            requestToggle.addEventListener("click", () => {
              if (requestData.style.display === "none") {
                requestData.style.display = "block";
                requestToggle.querySelector("span").textContent = "\u25BC Hide Request Data";
              } else {
                requestData.style.display = "none";
                requestToggle.querySelector("span").textContent = "\u25B6 Show Request Data";
              }
            });
          }
          if (entry.responseBody) {
            const responseToggle = logEntry.createDiv({ cls: "pouch-debug-toggle" });
            responseToggle.createEl("span", { text: "\u25B6 Show Response Data" });
            const responseData = logEntry.createEl("pre", {
              text: JSON.stringify(entry.responseBody, null, 2),
              cls: "pouch-debug-json"
            });
            responseData.style.display = "none";
            responseToggle.addEventListener("click", () => {
              if (responseData.style.display === "none") {
                responseData.style.display = "block";
                responseToggle.querySelector("span").textContent = "\u25BC Hide Response Data";
              } else {
                responseData.style.display = "none";
                responseToggle.querySelector("span").textContent = "\u25B6 Show Response Data";
              }
            });
          }
          if (entry.errorDetails) {
            const errorToggle = logEntry.createDiv({ cls: "pouch-debug-toggle" });
            errorToggle.createEl("span", { text: "\u25B6 Show Error Details" });
            const errorData = logEntry.createEl("pre", {
              text: JSON.stringify(entry.errorDetails, null, 2),
              cls: "pouch-debug-json pouch-debug-error-details"
            });
            errorData.style.display = "none";
            errorToggle.addEventListener("click", () => {
              if (errorData.style.display === "none") {
                errorData.style.display = "block";
                errorToggle.querySelector("span").textContent = "\u25BC Hide Error Details";
              } else {
                errorData.style.display = "none";
                errorToggle.querySelector("span").textContent = "\u25B6 Show Error Details";
              }
            });
          }
        });
        new import_obsidian.Setting(containerEl).setName("Clear Debug Log").setDesc("Remove all entries from the debug log").addButton((button) => button.setButtonText("Clear Debug Log").setWarning().onClick(async () => {
          this.plugin.settings.debugLog = [];
          await this.plugin.saveSettings();
          this.display();
        }));
      }
    }
    containerEl.createEl("style", {
      text: `
				.pouch-destination-container {
					border: 1px solid var(--background-modifier-border);
					border-radius: 4px;
					padding: 1em;
					margin: 1em 0;
					background: var(--background-secondary);
				}
				.pouch-destination-container h4 {
					margin-top: 0;
					margin-bottom: 0.5em;
					color: var(--text-accent);
				}
				.pouch-log-container {
					max-height: 400px;
					overflow-y: auto;
					border: 1px solid var(--background-modifier-border);
					border-radius: 4px;
					padding: 0.5em;
					margin: 1em 0;
					background: var(--background-secondary);
				}
				.pouch-log-entry {
					padding: 0.75em;
					margin-bottom: 0.5em;
					border-radius: 4px;
					background: var(--background-primary);
					border-left: 3px solid var(--interactive-accent);
				}
				.pouch-log-entry.pouch-log-error {
					border-left-color: var(--text-error);
				}
				.pouch-log-timestamp {
					font-weight: bold;
					margin-bottom: 0.25em;
					font-size: 0.9em;
				}
				.pouch-log-title, .pouch-log-slug {
					margin-bottom: 0.25em;
					font-size: 0.85em;
				}
				.pouch-log-url {
					margin-top: 0.25em;
					font-size: 0.85em;
				}
				.pouch-log-url a {
					color: var(--interactive-accent);
					text-decoration: none;
				}
				.pouch-log-url a:hover {
					text-decoration: underline;
				}
				.pouch-log-error-msg {
					color: var(--text-error);
					margin-top: 0.25em;
					font-size: 0.85em;
				}
				.pouch-log-empty {
					color: var(--text-muted);
					font-style: italic;
					margin: 1em 0;
				}
				.pouch-debug-log-container {
					max-height: 500px;
					overflow-y: auto;
					border: 1px solid var(--background-modifier-border);
					border-radius: 4px;
					padding: 0.5em;
					margin: 1em 0;
					background: var(--background-secondary);
				}
				.pouch-debug-log-entry {
					padding: 0.75em;
					margin-bottom: 0.5em;
					border-radius: 4px;
					background: var(--background-primary);
					border-left: 3px solid var(--text-muted);
					font-size: 0.9em;
				}
				.pouch-debug-log-entry.pouch-debug-error {
					border-left-color: var(--text-error);
				}
				.pouch-debug-log-entry.pouch-debug-request {
					border-left-color: var(--interactive-accent);
				}
				.pouch-debug-log-entry.pouch-debug-response {
					border-left-color: var(--interactive-success);
				}
				.pouch-debug-log-entry.pouch-debug-info {
					border-left-color: var(--text-accent);
				}
				.pouch-debug-header {
					font-weight: bold;
					margin-bottom: 0.5em;
					display: flex;
					justify-content: space-between;
					align-items: center;
				}
				.pouch-debug-timestamp {
					font-size: 0.85em;
					color: var(--text-muted);
				}
				.pouch-debug-message {
					margin-bottom: 0.5em;
					font-weight: 500;
				}
				.pouch-debug-detail {
					font-size: 0.85em;
					color: var(--text-muted);
					margin-bottom: 0.25em;
				}
				.pouch-debug-toggle {
					cursor: pointer;
					color: var(--interactive-accent);
					font-size: 0.85em;
					margin-top: 0.5em;
					user-select: none;
				}
				.pouch-debug-toggle:hover {
					text-decoration: underline;
				}
				.pouch-debug-json {
					background: var(--background-secondary);
					border: 1px solid var(--background-modifier-border);
					border-radius: 4px;
					padding: 0.5em;
					margin-top: 0.5em;
					font-size: 0.8em;
					overflow-x: auto;
					white-space: pre-wrap;
					word-wrap: break-word;
				}
				.pouch-debug-error-details {
					border-color: var(--text-error);
					background: var(--background-modifier-error);
				}
			`
    });
  }
};
